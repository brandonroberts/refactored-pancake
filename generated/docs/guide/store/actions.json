{
  "id": "guide/store/actions",
  "title": "Actions",
  "contents": "\n<div class=\"content\">\n<h1 id=\"actions\">Actions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/actions#actions\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"action-reducers\">Action reducers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/actions#action-reducers\"><i class=\"material-icons\">link</i></a></h2>\n<p>Provide the <code>ActionReducerMap&#x3C;T></code> with your reducer map for added type checking.</p>\n<code-example language=\"ts\">\nimport { ActionReducerMap } from '@ngrx/store';\nimport * as fromAuth from './auth.actions';\n\nexport interface State {\n  auth: fromAuth.State;\n}\n\nexport const reducers: ActionReducerMap&#x3C;State> = {\n  auth: fromAuth.reducer,\n};\n</code-example>\n<h2 id=\"typed-actions\">Typed Actions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/actions#typed-actions\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use strongly typed actions to take advantage of TypeScript's compile-time checking.</p>\n<code-example language=\"ts\">\n// counter.actions.ts\nimport { Action } from '@ngrx/store';\n\nexport enum CounterActionTypes {\n  INCREMENT = '[Counter] Increment',\n  DECREMENT = '[Counter] Decrement',\n  RESET = '[Counter] Reset',\n}\n\nexport class Increment implements Action {\n  readonly type = CounterActionTypes.INCREMENT;\n}\n\nexport class Decrement implements Action {\n  readonly type = CounterActionTypes.DECREMENT;\n}\n\nexport class Reset implements Action {\n  readonly type = CounterActionTypes.RESET;\n\n  constructor(public payload: number) {}\n}\n\nexport type CounterActionsUnion = Increment | Decrement | Reset;\n</code-example>\n<p>This provides typed actions for your reducer functions.</p>\n<code-example language=\"ts\">\n// counter.reducer.ts\nimport { CounterActionTypes, CounterActionsUnion } from './counter.actions';\n\nexport function reducer(state: number = 0, action: CounterActionsUnion): State {\n  switch (action.type) {\n    case CounterActionTypes.INCREMENT: {\n      return state + 1;\n    }\n\n    case CounterActionTypes.DECREMENT: {\n      return state - 1;\n    }\n\n    case CounterActionTypes.RESET: {\n      return action.payload; // typed to number\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n</code-example>\n<p>Instantiate actions and use <code>store.dispatch()</code> to dispatch them:</p>\n<code-example language=\"ts\">\nimport { Store, select } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport * as CounterActions from './counter.actions';\n\ninterface AppState {\n  counter: number;\n}\n\n@Component({\n  selector: 'my-app',\n  template: `\n    &#x3C;button (click)=\"increment()\">Increment&#x3C;/button>\n    &#x3C;button (click)=\"decrement()\">Decrement&#x3C;/button>\n    &#x3C;button (click)=\"reset()\">Reset Counter&#x3C;/button>\n\n    &#x3C;div>Current Count: {{ counter | async }}&#x3C;/div>\n  `,\n})\nexport class MyAppComponent {\n  counter: Observable&#x3C;number>;\n\n  constructor(private store: Store&#x3C;AppState>) {\n    this.counter = store.pipe(select('counter'));\n  }\n\n  increment() {\n    this.store.dispatch(new CounterActions.Increment());\n  }\n\n  decrement() {\n    this.store.dispatch(new CounterActions.Decrement());\n  }\n\n  reset() {\n    this.store.dispatch(new CounterActions.Reset(3));\n  }\n}\n</code-example>\n\n</div>"
}